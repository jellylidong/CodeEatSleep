## 算法概览
- 一个在weighted graph上使用的算法
- 初始条件为给定起点start和终点end
- 找到从起点到终点的least cost path

## 步骤
  1. 定义两个集合：
    visited存放存放[node, dist] pair，node为已经找到最短路径的结点，dist为对应的最短距离
    toStart为一个heap, 存放[node, dist] pair, node为结点，dist为从起点到该node的距离，heap按距离排序
  2. 将 [startNode, 0] 放入toStart 
  3. 遍历toStart中的node：
    - 如果该node已经在visited中，则从heap中移移除
      否则将该[node, dist]放入visited，并移除
    - 遍历该node所有邻居结点n
       - 如果当前邻居结点n已经在visited中则跳过
         否则，此时 从startNode到该n的距离dist 与 node到n的距离cost 之和
         将[n, dist+n.cost]放入toStart中
  4. 重复步骤3直到toStart变为控
  5. 此时visited中存放的就是node以及startNode到该node的最短距离

  - PS: 由于node放入toStart heap后会自动排序， 所以每次从heap中移出node，总能保证最短路径的node被放入visited中：
    也即，如果有node可以从多个路径到达，总是该node与最短路径的pair首先被从toStart heap中取出，并被放入visited中

## 伪代码
``` js
// graph node defination
class Node {
    List<NodeDistPair> neightbors;
    int cost;
}

// node and its distance to neighbor node
class NodeDistPair {
    Node node;
    int dist;
}

Dijkstra(List<Node> graph, Node start, Node end) {
    for node in graph{
        node.cost = infinite; // initilized cost as infinite
    }
    start.cost = 0; // initilize start node's cost to 0

    List<Node> toVisit;
    List<Node> visited;

    toVisit.add(start);
    for node in toVisit{
        for n in node.neighbors{
            if(node.cost + n.dist < n.cost) {
                n.cost = node.cost + n.dist;
                toVisit.add(n);
            }
        }
        toVisit.remove(node);
        visited.add(node);
    }

    return visited.contains(end)? end.cost: infinite;
}
```

## 演示
![alt text](https://raw.githubusercontent.com/jellylidong/CodeEatSleep/master/code/pics/Dijkstra_Animation.gif)






